# -*- coding: utf-8 -*-
"""DAY4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E167i2tzTxy0WigFeGbA_9TvniVS7ipC
"""

pip install requests python-dotenv google-generativeai

import os
import json
import requests
import google.generativeai as genai
from dotenv import load_dotenv

class ReActAgent:
    def __init__(self, topic):
        """Initialize the ReAct Agent with a topic."""
        if not topic or not isinstance(topic, str):
            raise ValueError("Topic must be a non-empty string.")
        self.topic = topic
        self.questions = []
        self.search_results = {}

        # Load environment variables
        load_dotenv()

        # Initialize Gemini client
        gemini_api_key = "AIzaSyBMeZz1rVfBNO7b0O0I4kcV07obEED4vFk"
        if not gemini_api_key:
            raise ValueError("GEMINI_API_KEY not found in .env file.")
        genai.configure(api_key=gemini_api_key)
        self.llm_client = genai.GenerativeModel("gemini-2.0-flash")

        # Get Tavily API key
        self.tavily_api_key = "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"
        if not self.tavily_api_key:
            raise ValueError("TAVILY_API_KEY not found in .env file.")

    def generate_research_questions(self):
        """Generate 5–6 research questions using Gemini 2.0 Flash."""
        prompt = (
            f"You are a research assistant. Given the topic '{self.topic}', "
            "generate a list of 5-6 well-structured research questions "
            "that cover different aspects of the topic. Ensure the questions are diverse, "
            "relevant, and clear. Return the questions as a JSON array of strings."
        )

        try:
            response = self.llm_client.generate_content(
                prompt,
                generation_config={
                    "response_mime_type": "application/json"
                }
            )
            questions = json.loads(response.text)
            if not isinstance(questions, list) or not all(isinstance(q, str) for q in questions):
                raise ValueError("LLM returned invalid questions format.")
            self.questions = questions[:6]
            return self.questions
        except Exception as e:
            print(f"Error generating questions: {e}")
            return []

    def search_web(self):
        """Use Tavily API to search the web for each research question."""
        headers = {
            "Authorization": f"Bearer {self.tavily_api_key}",
            "Content-Type": "application/json"
        }

        for question in self.questions:
            try:
                payload = {
                    "query": question,
                    "search_depth": "basic",
                    "include_answer": False,
                    "include_raw_content": False,
                    "max_results": 5
                }
                response = requests.post("https://api.tavily.com/search", headers=headers, json=payload)
                response.raise_for_status()
                data = response.json()

                results = [
                    {
                        "title": r.get("title", "No title"),
                        "content": r.get("content", "No content")
                    }
                    for r in data.get("results", [])[:5]
                ]
                self.search_results[question] = results
            except Exception as e:
                print(f"Error searching for question '{question}': {e}")
                self.search_results[question] = []

        return self.search_results

    def generate_report(self):
        """Generate a structured Markdown report based on search results."""
        report = f"# Research Report: {self.topic.capitalize()}\n\n"
        report += "## Introduction\n"
        report += (
            f"This report is generated by the ReAct Agent to provide insights into {self.topic}. "
            "The agent has used a series of research questions generated by the Gemini 2.0 Flash model "
            "to guide the research process, followed by relevant information gathered from web searches via Tavily API. "
            "The following sections address each research question with key findings.\n\n"
        )

        for question in self.questions:
            report += f"## Question: {question}\n"
            results = self.search_results.get(question, [])
            if not results:
                report += "No results found for this question.\n\n"
            else:
                report += "Key findings:\n"
                for idx, result in enumerate(results, 1):
                    report += (
                        f"{idx}. **{result['title']}**: "
                        f"{result['content'][:300]}... (Source truncated for brevity)\n"
                    )
                report += "\n"

        report += "## Conclusion\n"
        report += (
            f"This report has provided a comprehensive overview of {self.topic}. "
            "The findings highlight key aspects through targeted questions, "
            "drawing from recent web sources. Further research could explore "
            "additional dimensions or verify source credibility for deeper insights."
        )
        return report

def main():
    try:
        topic = input("Enter the topic you want to research: ").strip()
        if not topic:
            raise ValueError("Topic cannot be empty.")

        agent = ReActAgent(topic)

        print("\nGenerating research questions...")
        questions = agent.generate_research_questions()
        if not questions:
            print("Failed to generate questions. Exiting.")
            return
        for i, q in enumerate(questions, 1):
            print(f"{i}. {q}")

        print("\nSearching the web using Tavily...")
        results = agent.search_web()
        if not results:
            print("Failed to fetch results. Exiting.")
            return

        print("\nGenerating final report...")
        report = agent.generate_report()
        print("Report generated successfully.\n")

        with open("research_report_tavily_gemini.md", "w", encoding="utf-8") as f:
            f.write(report)
        print("✅ Report saved as 'research_report_tavily_gemini.md'")

    except Exception as e:
        print(f"❌ Error: {e}")

if __name__ == "__main__":
    main()